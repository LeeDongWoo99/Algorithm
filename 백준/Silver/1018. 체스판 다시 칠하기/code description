n,m=map(int,input().split())

ls=[]
cnt=[]
for i in range(n):
    ls.append(input())
    
for a in range(n-7):
    for b in range(m-7):  #8*8로 자르기 위해, -7해준다
        w_index=0   #흰색으로 시작
        b_index=0   #검은색으로 시작
        for i in range(a,a+8):  #시작지점
            for j in range(b,b+8):  #시작지점
                if (i+j)%2==0:  #짝수인 경우
                    if ls[i][j]!='W':  #W가 아니면, 즉 B이면
                        w_index+=1  #W로 칠하는 갯수
                    else:  #W일 때
                        b_index+=1  #B로 칠하는 갯수
                else:  #홀수인 경우
                    if ls[i][j]!='W':  #W가 아니면, 즉 B이면
                        b_index+=1  #B로 칠하는 갯수
                    else:
                        w_index+=1  #W로 칠하는 갯수
                        
        cnt.append(w_index)   #W로 시작할 때 경우의 수
        cnt.append(b_index)   #B로 시작할 때 경우의 수
print(min(cnt))
--------------------------------------------------------------------설명------------------------------------------------------------------
＃１
보드의 크기를 입력받는다。
＃３、＃４
원래의 판을 저장하기 위한 ｌｓ와 바뀐 채스판의 갯수를 저장하기 위해 ｃｎｔ 빈 리스트를 정의한다。
ㄴｃｎｔ를 리스트로 저장한 이유는 나중에 ｍｉｎ을 사용하기 위해 정의한다。
＃５、＃６
N(행)의 갯수만큼 원래의 판을 입력 받는다.
append(input())을 이용하여 ｌｓ에 추가 해준다.
＃８～＃２３
가능한 모든 경우의 수를 체크하기 위해 4중 for문을 사용한다.
첫번째, 두번째 for문은 전체 체스판에서 시작점을 잡기 위한 반복문이다.
ㄴ보드를 잘라서 ８、８ 크기의 체스판을 만들기로 해서 시작점을 찾기 위한 작업이다。
a는 행, b는 열에 대하여 원래의 체스 판에서 8*8로 자를 수 있는 범위의 시작점을 가리킨다.

Ｗ—index은 'W'로 시작할 경우 바뀐 체스 판의 갯수를 세기 위함이고,
Ｂ—index는 'B'로 시작할 경우 바뀐 체스 판의 갯수를 세기 위함이다.

ｉ＋ｊ의 합의 수가 짝수나 홀수일 때 각자 첫 조건이 다른 것을 볼 수 있는데 이유는 체스판의 특성 때문입니다. 
체스판에서는 가로나 세로로 한 칸씩 이동할 때마다 색이 바뀌므로, (i, j) 위치의 색깔은 i와 j의 합이 짝수일 때와 홀수일 때 각각 다릅니다.

i + j가 짝수인 경우: 시작점과 같은 색이어야 합니다. 따라서 시작점이 흰색(W)일 때 해당 칸의 색깔이 흰색(W)가 아니면 Ｗ—index을 1 늘리고,
시작점이 검은색(B)일 때 해당 칸의 색깔이 검은색(B)가 아니면 Ｂ—index를 1 늘립니다.
i + j가 홀수인 경우: 시작점과 다른 색이어야 합니다. 따라서 시작점이 흰색(W)일 때 해당 칸의 색깔이 검은색(B)가 아니면 Ｗ—index을 1 늘리고,
시작점이 검은색(B)일 때 해당 칸의 색깔이 흰색(W)가 아니면 Ｂ—index를 1 늘립니다.

＃２５～２７
'W'로 시작할 경우와 'B'로 시작할 경우 바뀐 체스판의 수 중 작은 수를 cnt 리스트에 더해준다.
모든 경우의 수를 다 체크한 후, ｍｉｎ을 통해 cnt 중 제일 작은 수를 출력하고 프로그램을 종료한다.
